using System.Text;
using Flowthru.Data.Validation;

namespace Flowthru.Data.Implementations;

/// <summary>
/// File-based catalog object for plaintext file storage.
/// </summary>
/// <remarks>
/// <para>
/// <strong>New in v0.4.0:</strong> This class provides file-based storage for plaintext content as strings.
/// Use this for unstructured text data, reports, logs, or any content that doesn't fit structured formats.
/// </para>
/// <para>
/// <strong>Schema Type:</strong> Uses <c>string</c> schema - the entire file content is loaded/saved as a single string.
/// </para>
/// <para>
/// <strong>Encoding Safety:</strong> Defaults to UTF-8 encoding. For binary or non-text files, encoding validation
/// will catch issues during inspection (if enabled). Use explicit encoding parameter for non-UTF-8 text files.
/// </para>
/// <para>
/// <strong>Use Cases:</strong>
/// - Markdown or HTML reports generated by pipelines
/// - Plaintext logs or diagnostic output
/// - Configuration files (JSON, YAML, XML as raw strings)
/// - Template files for text generation
/// - Unstructured text data for NLP ingestion
/// </para>
/// <para>
/// <strong>Validation:</strong> Implements <see cref="IShallowInspectable{T}"/> and <see cref="IDeepInspectable{T}"/>
/// to detect encoding issues before pipeline execution:
/// </para>
/// <list type="bullet">
/// <item><strong>Shallow:</strong> Validates file exists and first 4KB is valid in specified encoding</item>
/// <item><strong>Deep:</strong> Validates entire file content is valid in specified encoding</item>
/// </list>
/// <para>
/// <strong>Thread Safety:</strong> File I/O operations are inherently sequential. Concurrent access
/// may result in file locks or race conditions. Consider using separate file paths for concurrent writes.
/// </para>
/// <para>
/// <strong>Limitations:</strong>
/// - Not suitable for binary files (use byte[] schema with custom implementation)
/// - Entire file loaded into memory (use dataset implementations for large tabular data)
/// - No built-in compression (use custom implementation if needed)
/// </para>
/// </remarks>
/// <example>
/// <code>
/// // In catalog - UTF-8 text file (default)
/// public ICatalogObject&lt;string&gt; OutputReport =>
///     GetOrCreateObject(() => new FileCatalogObject(
///         "report",
///         $"{BasePath}/reports/output.md"));
/// 
/// // In catalog - specific encoding (e.g., Latin-1)
/// public ICatalogObject&lt;string&gt; LegacyLog =>
///     GetOrCreateObject(() => new FileCatalogObject(
///         "legacy_log",
///         $"{BasePath}/logs/legacy.txt",
///         Encoding.Latin1));
/// 
/// // Usage in node
/// var reportContent = await catalog.OutputReport.Load();
/// await catalog.OutputReport.Save("# Report\n\nGenerated content...");
/// 
/// // With validation in pipeline registration
/// builder.RegisterPipeline&lt;MyCatalog&gt;("reporting", ReportingPipeline.Create)
///   .WithValidation(validation => {
///     validation.Inspect(catalog.TemplateFile, InspectionLevel.Shallow);
///   });
/// </code>
/// </example>
public class FileCatalogObject : CatalogObjectBase<string>, IShallowInspectable<string>, IDeepInspectable<string> {
  private readonly string _filePath;
  private readonly Encoding _encoding;

  /// <summary>
  /// Creates a new file catalog object with UTF-8 encoding (default).
  /// </summary>
  /// <param name="key">Unique identifier for this catalog object</param>
  /// <param name="filePath">Path to the file (absolute or relative to working directory)</param>
  public FileCatalogObject(string key, string filePath)
      : this(key, filePath, Encoding.UTF8) {
  }

  /// <summary>
  /// Creates a new file catalog object with custom encoding.
  /// </summary>
  /// <param name="key">Unique identifier for this catalog object</param>
  /// <param name="filePath">Path to the file (absolute or relative to working directory)</param>
  /// <param name="encoding">Text encoding to use for reading/writing the file</param>
  /// <remarks>
  /// Common encodings:
  /// - <see cref="Encoding.UTF8"/> - Default, recommended for new files
  /// - <see cref="Encoding.ASCII"/> - 7-bit ASCII only
  /// - <see cref="Encoding.Unicode"/> - UTF-16 Little Endian
  /// - <see cref="Encoding.UTF32"/> - UTF-32
  /// - <see cref="Encoding.Latin1"/> - ISO-8859-1, legacy Western European
  /// </remarks>
  public FileCatalogObject(string key, string filePath, Encoding encoding)
      : base(key) {
    _filePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
    _encoding = encoding ?? throw new ArgumentNullException(nameof(encoding));
  }

  /// <summary>
  /// Gets the file path for this catalog object.
  /// </summary>
  public string FilePath => _filePath;

  /// <summary>
  /// Gets the text encoding used for reading/writing this file.
  /// </summary>
  public Encoding Encoding => _encoding;

  /// <inheritdoc/>
  public override async Task<string> Load() {
    if (!File.Exists(_filePath)) {
      throw new FileNotFoundException(
          $"File not found for catalog object '{Key}'", _filePath);
    }

    try {
      return await File.ReadAllTextAsync(_filePath, _encoding);
    } catch (DecoderFallbackException ex) {
      throw new InvalidOperationException(
          $"Failed to decode file '{_filePath}' as {_encoding.EncodingName} for catalog object '{Key}'. " +
          "The file may contain binary data or use a different encoding. " +
          "Consider using a different encoding or validating the file with InspectShallow/InspectDeep.",
          ex);
    }
  }

  /// <inheritdoc/>
  public override async Task Save(string data) {
    if (data == null) {
      throw new ArgumentNullException(nameof(data),
          $"Cannot save null data to catalog object '{Key}'");
    }

    // Ensure directory exists
    var directory = Path.GetDirectoryName(_filePath);
    if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory)) {
      Directory.CreateDirectory(directory);
    }

    await File.WriteAllTextAsync(_filePath, data, _encoding);
  }

  /// <inheritdoc/>
  public override Task<bool> Exists() {
    return Task.FromResult(File.Exists(_filePath));
  }

  /// <summary>
  /// Performs shallow inspection of the file (first 4KB).
  /// </summary>
  /// <param name="sampleSize">Ignored for file objects (uses fixed 4KB sample)</param>
  /// <remarks>
  /// <para>
  /// <strong>File-Specific Validation:</strong> This method provides efficient validation:
  /// </para>
  /// <list type="number">
  /// <item>Checks file existence</item>
  /// <item>Reads first 4KB of file content</item>
  /// <item>Validates sample is decodable in specified encoding</item>
  /// <item>Detects common binary file signatures (e.g., PNG, PDF, ZIP headers)</item>
  /// </list>
  /// <para>
  /// <strong>Performance:</strong> Fast (~10-50ms) since only samples the beginning of the file.
  /// Use this for default validation in most pipelines.
  /// </para>
  /// </remarks>
  public virtual async Task<ValidationResult> InspectShallow(int sampleSize = 100) {
    var result = new ValidationResult();

    try {
      // 1. Check file existence
      if (!File.Exists(_filePath)) {
        result.AddError(new ValidationError(
          Key,
          ValidationErrorType.NotFound,
          "File not found",
          $"Expected file at path: {_filePath}"));
        return result;
      }

      // 2. Read first 4KB as sample
      const int sampleBufferSize = 4096;
      byte[] buffer;
      
      await using (var stream = File.OpenRead(_filePath)) {
        var fileLength = (int)Math.Min(stream.Length, sampleBufferSize);
        buffer = new byte[fileLength];
        var bytesRead = 0;
        while (bytesRead < fileLength) {
          var read = await stream.ReadAsync(buffer.AsMemory(bytesRead, fileLength - bytesRead));
          if (read == 0) {
            break;
          }
          bytesRead += read;
        }
      }

      // 3. Check for binary file signatures (magic numbers)
      if (IsBinaryFileSignature(buffer)) {
        result.AddError(new ValidationError(
          Key,
          ValidationErrorType.InvalidFormat,
          "File appears to be binary",
          $"Detected binary file signature. Use byte[] schema or verify this is a text file. Encoding: {_encoding.EncodingName}"));
        return result;
      }

      // 4. Try to decode sample with specified encoding
      try {
        var decoder = _encoding.GetDecoder();
        decoder.Fallback = DecoderFallback.ExceptionFallback;
        var charCount = decoder.GetCharCount(buffer, 0, buffer.Length, flush: true);
        var chars = new char[charCount];
        decoder.GetChars(buffer, 0, buffer.Length, chars, 0, flush: true);
      } catch (DecoderFallbackException ex) {
        result.AddError(new ValidationError(
          Key,
          ValidationErrorType.TypeMismatch,
          "File contains invalid characters for encoding",
          $"Failed to decode sample as {_encoding.EncodingName}: {ex.Message}"));
        return result;
      }

      // 5. File appears valid
      return result;

    } catch (Exception ex) when (ex is not ArgumentException) {
      result.AddError(new ValidationError(
        Key,
        ValidationErrorType.InspectionFailure,
        "Unexpected error during inspection",
        $"Exception: {ex.GetType().Name}: {ex.Message}"));
      return result;
    }
  }

  /// <summary>
  /// Performs deep inspection of the entire file.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <strong>Comprehensive Validation:</strong> Validates the entire file content:
  /// </para>
  /// <list type="number">
  /// <item>All checks from <see cref="InspectShallow"/></item>
  /// <item>Reads and decodes entire file content</item>
  /// <item>Validates all bytes are valid in specified encoding</item>
  /// </list>
  /// <para>
  /// <strong>Performance Warning:</strong> Loads entire file into memory. Can be slow
  /// for large files. Use sparingly and opt-in explicitly.
  /// </para>
  /// </remarks>
  public virtual async Task<ValidationResult> InspectDeep() {
    var result = new ValidationResult();

    try {
      // 1. Run shallow inspection first
      var shallowResult = await InspectShallow();
      if (shallowResult.HasErrors) {
        return shallowResult;
      }

      // 2. Read and decode entire file
      try {
        var content = await File.ReadAllTextAsync(_filePath, _encoding);
        
        // Validate we got a string back (file may be empty, which is OK)
        if (content == null) {
          result.AddError(new ValidationError(
            Key,
            ValidationErrorType.InspectionFailure,
            "File read resulted in null",
            $"Unexpected null result when reading file: {_filePath}"));
        }
      } catch (DecoderFallbackException ex) {
        result.AddError(new ValidationError(
          Key,
          ValidationErrorType.TypeMismatch,
          "File contains invalid characters for encoding",
          $"Failed to decode entire file as {_encoding.EncodingName}: {ex.Message}"));
      }

      return result;

    } catch (Exception ex) when (ex is not ArgumentException) {
      result.AddError(new ValidationError(
        Key,
        ValidationErrorType.InspectionFailure,
        "Unexpected error during deep inspection",
        $"Exception: {ex.GetType().Name}: {ex.Message}"));
      return result;
    }
  }

  /// <summary>
  /// Detects common binary file signatures (magic numbers).
  /// </summary>
  /// <param name="buffer">First few bytes of the file</param>
  /// <returns>True if binary file signature detected</returns>
  private static bool IsBinaryFileSignature(byte[] buffer) {
    if (buffer.Length < 4) {
      return false;
    }

    // Common binary file signatures
    return buffer switch {
      // PNG: 89 50 4E 47
      [0x89, 0x50, 0x4E, 0x47, ..] => true,
      // PDF: 25 50 44 46
      [0x25, 0x50, 0x44, 0x46, ..] => true,
      // ZIP/JAR/DOCX: 50 4B 03 04 or 50 4B 05 06
      [0x50, 0x4B, 0x03 or 0x05, _, ..] => true,
      // GIF: 47 49 46 38
      [0x47, 0x49, 0x46, 0x38, ..] => true,
      // JPEG: FF D8 FF
      [0xFF, 0xD8, 0xFF, ..] => true,
      // EXE/DLL: 4D 5A
      [0x4D, 0x5A, ..] => true,
      // ELF: 7F 45 4C 46
      [0x7F, 0x45, 0x4C, 0x46, ..] => true,
      _ => false
    };
  }
}
