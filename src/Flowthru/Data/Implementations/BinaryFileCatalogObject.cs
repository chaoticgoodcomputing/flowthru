using Flowthru.Data.Validation;

namespace Flowthru.Data.Implementations;

/// <summary>
/// File-based catalog object for binary file storage.
/// </summary>
/// <remarks>
/// <para>
/// <strong>New in v0.4.0:</strong> This class provides file-based storage for binary content as byte arrays.
/// Use this for images, PDFs, compressed files, or any non-text data.
/// </para>
/// <para>
/// <strong>Schema Type:</strong> Uses <c>byte[]</c> schema - the entire file content is loaded/saved as raw bytes.
/// </para>
/// <para>
/// <strong>Use Cases:</strong>
/// - Image files (PNG, JPEG, SVG, etc.)
/// - PDF reports generated by pipelines
/// - Compressed archives (ZIP, GZIP)
/// - Binary model files (ML models, serialized objects)
/// - Audio/video files
/// - Protocol buffer or binary serialization formats
/// </para>
/// <para>
/// <strong>Validation:</strong> Implements <see cref="IShallowInspectable{T}"/> and <see cref="IDeepInspectable{T}"/>
/// to validate binary files before pipeline execution:
/// </para>
/// <list type="bullet">
/// <item><strong>Shallow:</strong> Validates file exists and checks file signature (magic numbers)</item>
/// <item><strong>Deep:</strong> Validates entire file can be read without I/O errors</item>
/// </list>
/// <para>
/// <strong>Thread Safety:</strong> File I/O operations are inherently sequential. Concurrent access
/// may result in file locks or race conditions. Consider using separate file paths for concurrent writes.
/// </para>
/// <para>
/// <strong>Memory Considerations:</strong>
/// - Entire file loaded into memory on Load()
/// - For large files (>100MB), consider streaming approaches or chunked processing
/// - Monitor memory usage for pipelines processing many binary files
/// </para>
/// </remarks>
/// <example>
/// <code>
/// // In catalog - PNG image file
/// public ICatalogObject&lt;byte[]&gt; VisualizationPng =>
///     GetOrCreateObject(() => new BinaryFileCatalogObject(
///         "visualization_png",
///         $"{BasePath}/reports/chart.png",
///         BinaryFileType.Png));
/// 
/// // In catalog - PDF report
/// public ICatalogObject&lt;byte[]&gt; MonthlyReport =>
///     GetOrCreateObject(() => new BinaryFileCatalogObject(
///         "monthly_report",
///         $"{BasePath}/reports/monthly.pdf",
///         BinaryFileType.Pdf));
/// 
/// // In catalog - unknown binary type
/// public ICatalogObject&lt;byte[]&gt; CustomBinary =>
///     GetOrCreateObject(() => new BinaryFileCatalogObject(
///         "custom_binary",
///         $"{BasePath}/data/model.bin"));
/// 
/// // Usage in node - save PNG from base64
/// var pngBytes = Convert.FromBase64String(base64String);
/// await catalog.VisualizationPng.Save(pngBytes);
/// 
/// // Usage in node - load and process
/// var pdfBytes = await catalog.MonthlyReport.Load();
/// ProcessPdf(pdfBytes);
/// </code>
/// </example>
public class BinaryFileCatalogObject : CatalogObjectBase<byte[]>,
    IShallowInspectable<byte[]>,
    IDeepInspectable<byte[]> {
  private readonly string _filePath;
  private readonly BinaryFileType? _expectedFileType;

  /// <summary>
  /// Creates a new binary file catalog object without type validation.
  /// </summary>
  /// <param name="key">Unique identifier for this catalog object</param>
  /// <param name="filePath">Path to the file (absolute or relative to working directory)</param>
  public BinaryFileCatalogObject(string key, string filePath)
      : this(key, filePath, expectedFileType: null) {
  }

  /// <summary>
  /// Creates a new binary file catalog object with expected file type validation.
  /// </summary>
  /// <param name="key">Unique identifier for this catalog object</param>
  /// <param name="filePath">Path to the file (absolute or relative to working directory)</param>
  /// <param name="expectedFileType">Expected file type for validation (null = no validation)</param>
  /// <remarks>
  /// When <paramref name="expectedFileType"/> is specified, shallow inspection will validate
  /// that the file's magic number matches the expected type. This helps catch errors where
  /// a file has the wrong extension or incorrect data was written.
  /// </remarks>
  public BinaryFileCatalogObject(string key, string filePath, BinaryFileType? expectedFileType)
      : base(key) {
    _filePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
    _expectedFileType = expectedFileType;
  }

  /// <summary>
  /// Gets the file path for this catalog object.
  /// </summary>
  public string FilePath => _filePath;

  /// <summary>
  /// Gets the expected file type for validation (null if no validation).
  /// </summary>
  public BinaryFileType? ExpectedFileType => _expectedFileType;

  /// <inheritdoc/>
  public override async Task<byte[]> Load() {
    if (!File.Exists(_filePath)) {
      throw new FileNotFoundException(
          $"File not found for catalog object '{Key}'", _filePath);
    }

    try {
      return await File.ReadAllBytesAsync(_filePath);
    } catch (IOException ex) {
      throw new InvalidOperationException(
          $"Failed to read binary file '{_filePath}' for catalog object '{Key}'.",
          ex);
    }
  }

  /// <inheritdoc/>
  public override async Task Save(byte[] data) {
    if (data == null) {
      throw new ArgumentNullException(nameof(data),
          $"Cannot save null data to catalog object '{Key}'");
    }

    // Ensure directory exists
    var directory = Path.GetDirectoryName(_filePath);
    if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory)) {
      Directory.CreateDirectory(directory);
    }

    await File.WriteAllBytesAsync(_filePath, data);
  }

  /// <inheritdoc/>
  public override Task<bool> Exists() {
    return Task.FromResult(File.Exists(_filePath));
  }

  /// <summary>
  /// Performs shallow inspection of the binary file (file signature validation).
  /// </summary>
  /// <param name="sampleSize">Ignored for binary file objects (uses fixed header sample)</param>
  /// <remarks>
  /// <para>
  /// <strong>Binary File Validation:</strong> This method provides efficient validation:
  /// </para>
  /// <list type="number">
  /// <item>Checks file existence</item>
  /// <item>Reads first 16 bytes (file signature/magic number)</item>
  /// <item>If expectedFileType is set, validates signature matches</item>
  /// <item>Detects common binary file types</item>
  /// </list>
  /// <para>
  /// <strong>Performance:</strong> Very fast (typically &lt;10ms) since only reads file header.
  /// </para>
  /// </remarks>
  public virtual async Task<ValidationResult> InspectShallow(int sampleSize = 100) {
    var result = new ValidationResult();

    try {
      // 1. Check file existence
      if (!File.Exists(_filePath)) {
        result.AddError(new ValidationError(
          Key,
          ValidationErrorType.NotFound,
          "File not found",
          $"Expected file at path: {_filePath}"));
        return result;
      }

      // 2. Read first 16 bytes for signature detection
      const int signatureSize = 16;
      byte[] signature;

      await using (var stream = File.OpenRead(_filePath)) {
        var readSize = (int)Math.Min(stream.Length, signatureSize);
        signature = new byte[readSize];
        var bytesRead = 0;
        while (bytesRead < readSize) {
          var read = await stream.ReadAsync(signature.AsMemory(bytesRead, readSize - bytesRead));
          if (read == 0) {
            break;
          }
          bytesRead += read;
        }
      }

      // 3. Detect file type from signature
      var detectedType = DetectFileType(signature);

      // 4. If expected type is specified, validate it matches
      if (_expectedFileType.HasValue && detectedType != _expectedFileType.Value) {
        result.AddError(new ValidationError(
          Key,
          ValidationErrorType.InvalidFormat,
          "File type mismatch",
          $"Expected {_expectedFileType.Value} but detected {detectedType}. " +
          $"File may be corrupted or have incorrect extension."));
        return result;
      }

      // 5. File signature is valid
      return result;

    } catch (Exception ex) when (ex is not ArgumentException) {
      result.AddError(new ValidationError(
        Key,
        ValidationErrorType.InspectionFailure,
        "Unexpected error during inspection",
        $"Exception: {ex.GetType().Name}: {ex.Message}"));
      return result;
    }
  }

  /// <summary>
  /// Performs deep inspection of the entire binary file.
  /// </summary>
  /// <remarks>
  /// <para>
  /// <strong>Comprehensive Validation:</strong> Validates the entire file:
  /// </para>
  /// <list type="number">
  /// <item>All checks from <see cref="InspectShallow"/></item>
  /// <item>Reads entire file to ensure no I/O errors</item>
  /// <item>Validates file size is reasonable</item>
  /// </list>
  /// <para>
  /// <strong>Performance Warning:</strong> Loads entire file into memory. For large files
  /// (>100MB), this can be slow and memory-intensive. Use sparingly.
  /// </para>
  /// </remarks>
  public virtual async Task<ValidationResult> InspectDeep() {
    var result = new ValidationResult();

    try {
      // 1. Run shallow inspection first
      var shallowResult = await InspectShallow();
      if (shallowResult.HasErrors) {
        return shallowResult;
      }

      // 2. Read entire file
      try {
        var content = await File.ReadAllBytesAsync(_filePath);

        // Validate we got data back
        if (content == null) {
          result.AddError(new ValidationError(
            Key,
            ValidationErrorType.InspectionFailure,
            "File read resulted in null",
            $"Unexpected null result when reading file: {_filePath}"));
        }
        // Note: For very large files (>100MB), consider using streaming approaches
      } catch (IOException ex) {
        result.AddError(new ValidationError(
          Key,
          ValidationErrorType.InspectionFailure,
          "Failed to read entire file",
          $"I/O error reading {_filePath}: {ex.Message}"));
      }

      return result;

    } catch (Exception ex) when (ex is not ArgumentException) {
      result.AddError(new ValidationError(
        Key,
        ValidationErrorType.InspectionFailure,
        "Unexpected error during deep inspection",
        $"Exception: {ex.GetType().Name}: {ex.Message}"));
      return result;
    }
  }

  /// <summary>
  /// Detects file type from binary signature (magic numbers).
  /// </summary>
  /// <param name="signature">First 16 bytes of the file</param>
  /// <returns>Detected file type, or Unknown if not recognized</returns>
  private static BinaryFileType DetectFileType(byte[] signature) {
    if (signature.Length < 4) {
      return BinaryFileType.Unknown;
    }

    return signature switch {
      // PNG: 89 50 4E 47 0D 0A 1A 0A
      [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, ..] => BinaryFileType.Png,
      // JPEG: FF D8 FF
      [0xFF, 0xD8, 0xFF, ..] => BinaryFileType.Jpeg,
      // GIF: 47 49 46 38
      [0x47, 0x49, 0x46, 0x38, ..] => BinaryFileType.Gif,
      // PDF: 25 50 44 46
      [0x25, 0x50, 0x44, 0x46, ..] => BinaryFileType.Pdf,
      // ZIP/JAR/DOCX: 50 4B 03 04 or 50 4B 05 06
      [0x50, 0x4B, 0x03 or 0x05, _, ..] => BinaryFileType.Zip,
      // GZIP: 1F 8B
      [0x1F, 0x8B, ..] => BinaryFileType.Gzip,
      // BMP: 42 4D
      [0x42, 0x4D, ..] => BinaryFileType.Bmp,
      // WebP: 52 49 46 46 ... 57 45 42 50
      [0x52, 0x49, 0x46, 0x46, _, _, _, _, 0x57, 0x45, 0x42, 0x50, ..] => BinaryFileType.WebP,
      // MP4: various, but often 66 74 79 70 at bytes 4-7
      [_, _, _, _, 0x66, 0x74, 0x79, 0x70, ..] => BinaryFileType.Mp4,
      _ => BinaryFileType.Unknown
    };
  }
}

/// <summary>
/// Common binary file types that can be detected from file signatures.
/// </summary>
public enum BinaryFileType {
  /// <summary>Unknown or unsupported file type</summary>
  Unknown,

  /// <summary>PNG image (89 50 4E 47)</summary>
  Png,

  /// <summary>JPEG image (FF D8 FF)</summary>
  Jpeg,

  /// <summary>GIF image (47 49 46 38)</summary>
  Gif,

  /// <summary>BMP image (42 4D)</summary>
  Bmp,

  /// <summary>WebP image (52 49 46 46 ... 57 45 42 50)</summary>
  WebP,

  /// <summary>PDF document (25 50 44 46)</summary>
  Pdf,

  /// <summary>ZIP archive (50 4B 03/05)</summary>
  Zip,

  /// <summary>GZIP compressed file (1F 8B)</summary>
  Gzip,

  /// <summary>MP4 video (66 74 79 70 at offset 4)</summary>
  Mp4
}
